<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Introduction</h2>

<p>This vignette presents the <code>R</code> package <code>RationalExp</code> associated to  @DGM (DGM hereafter). This package implements a test of the rational expectations hypothesis  based on the marginal distributions of realizations and subjective beliefs. This test can be used in cases where realizations and subjective beliefs are observed in two different datasets that cannot be matched, or when they are observed in the same dataset. The test can be implemented with covariates and survey weights. The package also computes the estimator of the  minimal deviations from rational expectations than can be rationalized by the data.</p>

<h2>How to get started</h2>

<p>The <code>R</code> package <code>RationalExp</code> can be downloaded from Github <a href="https://github.com/cgaillac/RationalExp">https://github.com/cgaillac/RationalExp</a>. To
install the <code>RationalExp</code> package from Github, the <code>devtools</code> library is required. We then use the command:</p>

<pre><code class="r"># library(&quot;devtools&quot;)
# install_github(&#39;cgaillac/RationalExp&#39;)
</code></pre>

<p>The most current version of the package (development version) is maintained only on Github. Provided that one has a proper internet connection and a write permission on the appropriate system directories, the installation of the package should proceed automatically. If the direct download and installation does not work, one can install the <code>RationalExp</code> package by simply downloading the source package, and then typing:</p>

<pre><code class="r">#install.packages(&quot;personal_directory/RationalExp_1.1.tar.gz&quot;, repos=NULL)
</code></pre>

<p>Once the <code>RationalExp</code> package is installed, it can be loaded to the current <code>R</code> session by the command <code>library(RationalExp)</code>.</p>

<p>Online help is available in two ways: either <code>help(package=&quot;RationalExp&quot;)</code> or <code>?test</code>. The first gives an overview over the available commands in the package. The second gives detailed information about a specific command. A valuable feature of <code>R</code> help files is that the examples used to illustrate commands are executable, so they can be pasted into an <code>R</code> session or run as a group with a command like <code>example(test)</code>.</p>

<pre><code class="r">library(RationalExp)
</code></pre>

<h2>Theory</h2>

<h3>Testing rational expectations</h3>

<p>We first explain the test procedure proposed in DGM for the test with covariates:
\begin{align<em>}
\text{H}_{0X}: &amp; \text{ there exists a pair of random variables } (Y&#39;,\psi&#39;) \text{ and a sigma-algebra } \mathcal{I}&#39; \
&amp; \text{ such that } \sigma(\psi&#39;, X) \subset \mathcal{I}&#39;, \  Y&#39;|X\sim Y|X , \, \psi&#39;|X \sim \psi|X \text{ and } \mathbb{E}\left[ Y&#39;|\mathcal{I}&#39;\right]=\psi&#39;.
\end{align</em>}</p>

<p>To simplify notation,  we use as in DGM a potential outcome framework to describe our data combination problem. Specifically, instead of observing \((Y,\psi)\), we suppose to observe only the covariates \(X\),  \(\widetilde{Y} = DY + (1-D)\psi\) and \(D\), where \(D=1\) (resp. \(D=0\)) if the unit belongs to the dataset of \(Y\) (resp. \(\psi\)). We assume that the two samples are drawn from the same population, which amounts to supposing that  \(D\perp\!\!\!\perp (X, Y,\psi)\). In order to build  DGM&#39;s test,  DGM use the following characterization of \(\text{H}_{0X}\):
\[  \mathbb{E}\left[ \left(y-Y\right)^+  - \left(y-\psi\right)^+\middle| X \right] \geq 0 \quad \forall y\in \mathbb{R} \text{ and}  \quad \mathbb{E}\left[  Y - \psi\middle| X\right] =0,\]
where \(u^+ =\max(0,u)\). Equivalently but written with \(\widetilde{Y}\) only,
\[\mathbb{E}\left[ W \left(y-\widetilde{Y}\right)^+\middle|X\right]\geq 0  \quad \forall y\in \mathbb{R} \text{ and} \quad \mathbb{E}\left[W\widetilde{Y}\middle|X\right]= 0,\]
where \(W=D/\mathbb{E}(D)-(1-D)/\mathbb{E}(1-D)\). This formulation of the null hypothesis allows one to apply the instrumental functions approach of @andrews2016inference (AS hereafter), who consider the issue of testing many conditional moment inequalities and equalities. The initial step is to transform the conditional moments into the following unconditional moments conditions:
\[  \mathbb{E}\left[W\left(y-\widetilde{Y}\right)^+ h(X)\right] \geq 0,  \quad \mathbb{E}\left[\left(  Y - \psi\right)h(X)\right] =0 .\]
for all \(y\in \mathbb{R}\) and \(h\geq 0\) belonging to a suitable class of functions.</p>

<p>\medskip
We suppose to observe here a sample \((D_i, X_i, \widetilde{Y}_i)_{i=1&hellip;n}\) of \(n\) i.i.d. copies of \((D,X,\widetilde{Y})\). For notational convenience, we let \(\widetilde{X}_i\) denote the nontransformed vector of covariates and redefine \(X_i\) as the transformed vector in the following way: 
\[X_i=\Phi_0\left( \widehat{\Sigma}_{ \widetilde{X},n}^{-&frac12;}\left(  \widetilde{X}_{i} - \overline{ \widetilde{X}}_{i}\right)\right),\]<br/>
where, for any \(x=(x_1,\dots,x_{d_X})\), we let \(\Phi_0(x)=\left( \Phi(x_1) , \dots, \Phi\left(x_{d_X} \right)\right)^{\top}\). Here \(\Phi\) denotes the standard normal cdf,  \(\widehat{\Sigma}_{\widetilde{X},n}\) is the sample covariance matrix of \(\left(\widetilde{X}_i\right)_{i=1&hellip;n}\) and  \(\overline{\widetilde{X}}_n\) its sample mean. </p>

<p>\medskip
Now that \(X_i \in [0,1]^{d_X}\), we consider \(h\) functions that are indicators of belonging to specific hypercubes within \([0,1]^{d_X}\). Namely, we consider the class of functions \(\mathcal{H}_r= \left\{h_{a,r}, \; a\in A_r\right\}\), with
\(A_r= \left\{1,2,\dots, 2r\right\}^{d_X}\) (\(r\geq 1\)), \(h_{a,r}(x) = 1\left\{x \in  C_{a,r}\right\}\) and, for any \(a=(a_1,&hellip;,a_{d_X})^{\top}\in A_r\),
\[C_{a,r} = \prod_{u=1}^{d_X} \left(\frac{a_u -1 }{2r}, \frac{a_u }{2r}\right].\] </p>

<p>\medskip
To define the test statistic \(T\), we need to introduce additional notation. First, we define, for any given \(y\),
    \begin{eqnarray}\label{eq:mn}
 m\left(D<em>i,\widetilde{Y}_i, X_i, h,y\right) =\left( \begin{array}{c}  m</em>{1}\left(D<em>i,\widetilde{Y}_i, X_i, h,y\right) \  m</em>{2}\left(D<em>i,\widetilde{Y}_i, X_i, h,y\right) 
    \end{array} \right) 
    = \left( \begin{array}{c} w_i\left(y - \widetilde{Y}_i\right)<sup>+h\left(X_i\right)</sup> \
     w_i\widetilde{Y}_i h\left(X_i\right)
    \end{array} \right),
\end{eqnarray}
where $w_i=nD_i/\sum</em>{j=1}<sup>n</sup> D<em>j - n(1-D_i)/\sum</em>{j=1}<sup>n(</sup> 1-D<em>j)$. Let $\overline{m}_n (h,y)= \sum</em>{i=1}<sup>{n}</sup> m\left(D<em>i,\widetilde{Y}_i, X_i, h,y\right)/n$ and define similarly $\overline{m}</em>{n,j}$ for \(j=1,2\). For any function \(h\) and any \(y\in\mathbb{R}\), let us also define, for some \(\epsilon>0\),
 \[ \overline{\Sigma}_n(h,y) = \widehat{\Sigma}_n(h,y) + \epsilon \mathrm{Diag}\left(   \widehat{\mathbb{V}}\left(\widetilde{Y} \right)  , \widehat{\mathbb{V}}\left(\widetilde{Y} \right)     \right),\]
  where \(\widehat{\Sigma}_n(h,y)\) is the sample covariance matrix of \(\sqrt{n}\overline{m}_n\left( h,y\right)\) and 
  \(\widehat{\mathbb{V}}\left(\widetilde{Y}\right)\) is the empirical variance of \(\widetilde{Y}\). We then denote by \(\overline{\Sigma}_{n,jj}(h,y) (j=1,2)\) the \(j\)-th diagonal term of \(\overline{\Sigma}_{n}(h,y)\). </p>

<p>\medskip
  Then the (Cram\&#39;{e}r-von-Mises) test statistic \(T\) is defined by:
\[ T= \sup_{y \in \widehat{\mathcal{Y}}} \sum_{r=1}^{r_n}\frac{(2r)^{-d_X}}{\left(r^2 + 100\right) } \sum_{a\in A_r} \left( \left(1-p\right)\left( - \frac{\sqrt{n} \overline{m}_{n,1}\left(h_{a,r},y\right)}{ \overline{\Sigma}_{n,11}(h_{a,r},y)^{&frac12;} } \right)^{+2} + p \left(  \frac{\sqrt{n} \overline{m}_{n,2}\left(h_{a,r},y\right)}{\overline{\Sigma}_{n,22}(h_{a,r},y)^{&frac12;}}  \right)^2\right),\]
where \(\widehat{\mathcal{Y}} =\left[\min_{i=1,\dots,n}\widetilde{Y}_i, \max_{i=1,\dots,n}\widetilde{Y}_i \right]\), \(p\) is a parameter that weights the moments inequalities versus equalities and \((r_n)_{n\in\mathbb{N}}\) is a deterministic sequence tending to infinity. </p>

<p>\medskip
To test for rational expectations in the absence of covariates, we simply restrict ourselves to the constant function \(h(X)=1\), and the test statistic is simply
\[ T= \sup_{y \in \widehat{\mathcal{Y}}} \left(1-p\right)\left( - \frac{\sqrt{n} \overline{m}_{n,1}(y)}{\overline{\Sigma}_{n,11}(y)^{&frac12;} } \right)^{+2} + p \left(  \frac{\sqrt{n} \overline{m}_{n,2}(y)}{\overline{\Sigma}_{n,22}(y)^{&frac12;}}  \right)^2,\]
where  \(\overline{m}_{n,j}(y)\) and \(\overline{\Sigma}_{n,jj}(y)\) \((j=1,2)\) are defined as above but with \(h(x)=1\).</p>

<p>\medskip
Whether or not covariates are included, the resulting test is of the form \(\varphi_{n,\alpha} = 1\left\{T> c^*_{n,\alpha}\right\}\) where the estimated critical value \(c^*_{n,\alpha}\) is obtained by bootstrap using as in AS the Generalized Moment Selection method. Specifically, we follow these three steps:
\begin{enumerate}
\item Compute the function $ \overline{\varphi}<em>n\left(y,h\right) = \left(\overline{\varphi}</em>{n,1}\left(y,h\right), 0  \right)<sup>{\top}</sup> $ for $ (y,h) $ in $ \widehat{\mathcal{Y}}\times\cup<em>{r=1}<sup>{r_n}</sup> \mathcal{H}</em>{r} $, with
\[  \overline{\varphi}_{n,1}\left(y,h\right) = \overline{\Sigma}_{n,11}^{&frac12;} B_n1\left\{   \frac{n^{&frac12;}}{\kappa_n} \overline{\Sigma}_{n,11}^{-&frac12;}\overline{m}_{n,1}(y,h)  >1  \right\} , \]
and where $ B<em>n =  \left(b_0\ln(n)/\ln(\ln(n))\right)<sup>{&frac12;}</sup> $, $ b_0 &gt;0 $, $ \kappa_n =(\kappa\ln(n))<sup>{&frac12;}$,</sup> and \(\kappa>0\). To compute $\overline{\Sigma}</em>{n,11}$, we fix \(\epsilon\) to \(0.05\), as in AS.
\item Let \(\left(D_i^*,\widetilde{Y}_i^*, X_i^*\right)_{i=1,&hellip;,n}\) denote a bootstrap sample, i.e., an i.i.d. sample from the empirical cdf of \(\left(D,\widetilde{Y}, X\right)\), and compute from this sample $ \overline{m}<em>n<sup>*</sup> $ and $ \overline{\Sigma}</em>{n}<sup>*</sup> $. Then compute \(T^*\) like \(T\), replacing $ \overline{\Sigma}<em>{n}\left(y,h</em>{a,r}\right)$  and $ \sqrt{n}\overline{m}<em>n\left(y,h</em>{a,r}\right) $ by  $ \overline{\Sigma}<em>{n}<sup>*\left(y,h</sup></em>{a,r}\right)$ and \[\sqrt{n}\left( \overline{m}_n^* - \overline{m}_n \right)\left(y,h_{a,r}\right) +  \overline{\varphi}_n\left(y,h_{a,r}\right).\]
\item The threshold \(c^*_{n,\alpha}\) is the (conditional) quantile of order \(1-\alpha + \eta\) of \(T^* +\eta\) for some $ \eta &gt;0 $. Following AS, we set \(\eta\) to $10<sup>{-6}</sup> $. 
\end{enumerate}</p>

<h3>Minimal Deviations from Rational Expectations</h3>

<p>In DGM, we also introduce the minimal deviations from rational expectations, as the unique function \(g^*\) satisfying: \[\mathbb{E}[\rho(|\psi-g^*(\psi)|)] = \inf_{(Y',\psi',\psi'&lsquo;)\in \mathbf{\Psi}}\mathbb{E}[\rho(|\psi&rsquo;-\psi'&lsquo;|)].\]
We refer the user to DGM for the motivation behind the computation of \(g^*\) and the formal existence and unicity result. Though \(g^*\) does not have a simple form in general, DGM propose in the following a simple procedure to construct a consistent estimator of it, based on i.i.d. copies \((Y_i)_{i=1&hellip;L}\) and \((\psi_i)_{i=1&hellip;L}\) of \(Y\) and \(\psi\). For simplicity, we suppose hereafter that the two samples have equal size. If both samples do not have equal size, one can first apply our analysis after taking a random subsample of the larger one, with the same size as the smaller one. Then we can compute the average of the estimates over a large number of such random subsamples.</p>

<p>\medskip
To define the DGM&#39;s estimator, note first that we have
\begin{equation}\label{eq:pb<em>ref}
g<sup>*=</sup> \arg\min</em>{g\in \mathcal{G}_0} \mathbb{E}\left[\left( \psi - g(\psi)\right)<sup>2</sup> \right],
\end{equation}
where the set \(\mathcal{G}_0\) is defined by
\[\mathcal{G}_0=\left\{g\  \text{non-decreasing}: \mathbb{E}\left[(y-Y)^+-(y-g(\psi))^+\right]\geq 0 \; \forall y\in\mathbb{R}, \; \mathbb{E}[g(\psi)]  = \mathbb{E}[Y]\right\}.\]
In other words, \(g^*\) is the (increasing) function     such that (i) \(g^*(\psi)\) is closest to \(\psi\) for the \(L^2\) norm; (ii) \(g^*\) belongs to \(\mathcal{G}_0\), which means that we can rationalize \(\mathbb{E}(Y|g^*(\psi))=g^*(\psi)\).</p>

<p>\medskip
To estimate \(g^*\), we replace expectations and cdfs by their empirical counterpart. Letting \(\psi_{(1)}<...< \psi_{(L)}\) denote the ordered statistic, our estimator of \(\left(g^*(\psi_{(1)}),...,g^*(\psi_{(L)})\right)\) is the solution of:
\begin{align}
\left(\widehat{g}<sup><em>(\psi_{(1)}),&hellip;,\widehat{g}^</em>(\psi_{(L)})\right)</sup> =  \arg\min<em>{ \widetilde{\psi}</em>{(1)} &lt; \dots &lt; \widetilde{\psi}<em>{(L)}   } \sum</em>{i=1}<sup>L\left(</sup> \psi<em>{(i)} - \widetilde{\psi}</em>{(i)}\right)<sup>2</sup> \ \text{s.t.} &amp; \sum<em>{i=j}<sup>L</sup> Y</em>{(i)} - \widetilde{\psi}<em>{(i)} \geq 0, \; j=2&hellip;L, \nonumber \
&amp; \sum</em>{i=1}<sup>L</sup> Y<em>{(i)} - \widetilde{\psi}</em>{(i)} = 0.
 \label{eq:prgm<em>quad}
\end{align}
Then, for any \(t\in \mathbb{R}\), we let 
$$\widehat{g}<sup><em>(t)=\widehat{g}^</em>\left(\min{(\psi_i)</sup></em>{i=1&hellip;L}:\psi<em>i\geq \min{t,\psi</em>{(L)}}\right).$$
We solve the above   convex quadratic programming problem using the algorithm proposed in  @suehiro2012online. We refer to DGM for more details.</p>

<h2>The functions in the RationalExp package</h2>

<h3>The test function</h3>

<p>Clean memory and load the package via</p>

<pre><code class="r">rm(list=ls())
### load packages
library(snowfall)
#&gt; Loading required package: snow
library(RationalExp)
set.seed(1829384)
</code></pre>

<p>This function implements the RE tests proposed in DGM. The code of the <code>test</code> function is based on the Stata code <code>cmi\_test</code> from @andrews2017commands. The syntax of the function <code>test</code> is as follows: <code>test(Y_tilde,D,X,weights,generalized,nbCores,tuningParam)</code>.</p>

<p>\begin{tabular}{lp{370pt}}
<code>Y\_tilde</code> &amp; a vector of size \(n_Y+n_\psi\) stacking first the \((Y_i)_{i=1,&hellip;,n_Y}\), then the \((\psi_i)_{i=1,&hellip;,n_\psi}\). \
<code>D</code> &amp; a vector stacking the \((D_i)_{i=1&hellip;n}\): \(n_Y\) ones, then \(n_\psi\) zeros. \
<code>X</code> &amp; the matrix of covariates. Equal to a vector of ones by default (in which case the test without covariates is performed). \
<code>weights</code> &amp; the vector of survey weights. Uniform by default. \
<code>generalized</code> &amp; whether a generalized test should be performed or not: &ldquo;Add&rdquo; for additive shocks (default),  &ldquo;Mult&rdquo; for multiplicative shocks. Set by default to &ldquo;No&rdquo; (no generalized test). \
<code>nbCores</code> &amp; the number of cores used by the program. To reduce the computational time, this function can use several cores, in which case the library <code>snowfall</code> should be loaded first. By default, <code>nbCores</code> is set to 1.\ 
<code>tuningParam</code> &amp; a dictionnary, including the parameters <code>p</code>, <code>epsil</code>, <code>B</code>, <code>c</code>, <code>kap</code>, and <code>y\_grid</code>. The first four corresponds to the parameters \(p\), \(\epsilon\), \(B\), \(c\), and \(\kappa\) above (with default values equal to 0.05, 0.05, 500, 0.3 and 0.001 respectively). Following AS, the interval \(\widehat{\mathcal{Y}}=\left[\min_{i=1&hellip;n} \widetilde{Y}_i,\max_{i=1,&hellip;,n} \widetilde{Y}_i \right]\) is approximated by a grid denoted by <code>y\_grid</code>. By default, <code>y\_grid</code> is equal to the empirical quantiles of  \(\widetilde{Y}\) of order \(0\),  \(1/29\) \(2/29\),&hellip;, and 1.
\end{tabular}</p>

<h3>The estimDev function</h3>

<p>This function estimates the minimal deviations from RE. The <code>estimDev</code>() function has the following syntax <code>es  timDev(psi, y)</code></p>

<p>\begin{tabular}{lp{370pt}}
<code>psi</code> &amp; vector of subjective expectations \
<code>y</code> &amp; vector of realizations of an individual outcome.
\end{tabular}</p>

<p>\medskip
Both vectors should have the same length. If not, one can randomly select a subset of the longer vector with length equal to that of the shorter one. The function returns a function via the <code>approxfun</code> of the package <code>stats</code>. This function can then be evaluated directly on a desired grid. We give an exampl below.</p>

<h2>Examples</h2>

<h3>Test without covariates</h3>

<p>We consider the same DGP as in DGM (Section 5), namely we suppose that the outcome \(Y\) is given by
\[ Y = \rho \psi  + \epsilon,\]
with \(\rho \in [0,1]\), \(\psi \sim \mathcal{N}(0,1)\) and
\[\epsilon =  \zeta \left(-1\{U \leq 0.1\} + 1\{U \geq 0.9\}\right),\]
where \(\zeta\), \(U\) and \(\psi\) are mutually independent, \(\zeta \sim \mathcal{N}(2, 0.1)\) and \(U\sim \mathcal{U}[0,1]\). We consider 1,200 observations and \(\rho=0.29\).</p>

<pre><code class="r">### Data generating process
n_p=1200 # number of observations
n_y=n_p
N &lt;- n_y + n_p
rho &lt;-0.29 # parameter rho
sig=0.1 # parameter sigma
u=1
b=0.10
a=2
psi &lt;-rnorm(n_p,0,u) ## vector of psi&#39;s
pp_y &lt;- runif(n_y,0,1)
zeta &lt;- rnorm(n_y,a,sig)
zeta1 &lt;- rnorm(n_y,-a,sig)
pp1_y &lt;- 1*(pp_y &lt;b)
pp2_y &lt;- 1*(pp_y &gt;1-b)
pp3_y &lt;- 1*(pp_y &lt;=(1-b) &amp; pp_y &gt;=b)
psi_y &lt;-rnorm(n_y,0,u)
y =  rho*psi_y+ pp1_y*zeta + pp2_y*zeta1 ## vector of y&#39;s
</code></pre>

<p>Concatentate the two datasets: </p>

<pre><code class="r">D &lt;- rbind(matrix(1,n_y,1),matrix(0,n_p,1)) ## vector of D&#39;s
Y_tilde &lt;- rbind(matrix(y,n_y,1),matrix(psi,n_p,1))  ## concatenation of y then psi
</code></pre>

<p>By default, the function <code>test</code> runs the test without covariates, where <code>system.time</code>() is used to compute the elapsed time: </p>

<pre><code class="r">system.time(res &lt;- test(Y_tilde ,D))
#&gt; Conditional Moment Inequalities Test   Number of obs :  2400 
#&gt; Test Statistic :  4.697479 
#&gt;  Critical Value (1%)  2.51336 
#&gt; Critical Value (5%)  0.9971287 
#&gt; Critical Value (10%)  0.7172106 
#&gt; p-value  :  0
#&gt;    user  system elapsed 
#&gt;   31.27    0.04   76.70
</code></pre>

<p>The test prints the total number of observations,  the test statistic, the different critical values, and the p-value. It returns a list containing all these informations and the vector of bootstraped test statistics (see the reference manual).</p>

<p>We now show how to modify the tuning parameter of the number of cores <code>nbClust</code> (in tuningParam) to 3 and run the test of the parallelized version of the test:</p>

<pre><code class="r">system.time(res &lt;- test(Y_tilde ,D,NULL,NULL,NULL,3,NULL))
#&gt; Warning in searchCommandline(parallel, cpus = cpus, type = type,
#&gt; socketHosts = socketHosts, : Unknown option on commandline:
#&gt; tools::buildVignettes(dir
#&gt; R Version:  R version 3.4.4 (2018-03-15)
#&gt; snowfall 1.84-6.1 initialized (using snow 0.4-3): parallel execution on 3 CPUs.
#&gt; 
#&gt; Stopping cluster
#&gt; Conditional Moment Inequalities Test   Number of obs :  2400 
#&gt; Test Statistic :  4.697479 
#&gt;  Critical Value (1%)  2.532613 
#&gt; Critical Value (5%)  1.28576 
#&gt; Critical Value (10%)  0.8261835 
#&gt; p-value  :  0
#&gt;    user  system elapsed 
#&gt;    0.89    0.22   36.44
</code></pre>

<p>Note that elapsed time has been divided by 1.63. </p>

<p>Then, we give a last example where we modify, where we modify the parameter &ldquo;prec&rdquo;</p>

<pre><code class="r">tuningParam&lt;- vector(mode=&quot;list&quot;, length=6)
tuningParam[[&quot;p&quot;]] &lt;- 0.05
tuningParam[[&quot;epsilon&quot;]] &lt;- 0.05
tuningParam[[&quot;B&quot;]] &lt;-500
tuningParam[[&quot;y_grid&quot;]] &lt;- quantile(Y_tilde,seq(0,1,length.out=50))
tuningParam[[&quot;c&quot;]] &lt;- 0.3
tuningParam[[&quot;kappa&quot;]] &lt;- 0.001
</code></pre>

<pre><code class="r">system.time(res &lt;- test(Y_tilde ,D,NULL,NULL,NULL,3,tuningParam))
#&gt; Warning in searchCommandline(parallel, cpus = cpus, type = type,
#&gt; socketHosts = socketHosts, : Unknown option on commandline:
#&gt; tools::buildVignettes(dir
#&gt; snowfall 1.84-6.1 initialized (using snow 0.4-3): parallel execution on 3 CPUs.
#&gt; 
#&gt; Stopping cluster
#&gt; Conditional Moment Inequalities Test   Number of obs :  2400 
#&gt; Test Statistic :  4.699084 
#&gt;  Critical Value (1%)  2.718392 
#&gt; Critical Value (5%)  1.269613 
#&gt; Critical Value (10%)  0.8245907 
#&gt; p-value  :  0.002004008
#&gt;    user  system elapsed 
#&gt;    0.81    0.15   50.16
</code></pre>

<h3>Test with covariates</h3>

<p>We now present an example of the test with covariates. We consider the same DGP as in DGM (Appendix D), namely we suppose that the outcome \(Y\) is given by the following DGP: 
\[ Y = \rho \psi  + \sqrt{X}\epsilon,\]
with \(\rho \in [0,1]\), \(\psi \sim \mathcal{N}(0,1)\), \(X\sim \text{Beta}(0.1, 10)\) and
\[\epsilon=  \zeta \left(-1\{U \leq 0.1\} + 1\{U \geq 0.9\}\right),\]
where \(\zeta \sim \mathcal{N}(2, 0.1)\) and \(U\sim \mathcal{U}[0,1]\). \((\psi, \zeta, U, X)\) are supposed to be mutually independent. Again we start with the data generating process:</p>

<pre><code class="r">n_p=1200
n_y=n_p
N &lt;- n_y + n_p
sig=0.1
u=1
b=0.10
a=2
alp = 0.1
bet = 10

# Data Generating process
X_p = rbeta(n_p,alp ,  bet)+1 
X_y =  rbeta(n_y,alp ,  bet)+1 
transf &lt;- function(X_y,   f0){
  res &lt;-f0*sqrt(X_y)
  return(res)
}
psi &lt;-rnorm(n_p,0,u)
pp_y &lt;- runif(n_y,0,1)
zeta &lt;- rnorm(n_y,a,sig)
zeta1 &lt;- rnorm(n_y,-a,sig)
pp1_y &lt;- 1*(pp_y &lt;b)
pp2_y &lt;- 1*(pp_y &gt;1-b)
pp3_y &lt;- 1*(pp_y &lt;=(1-b) &amp; pp_y &gt;=b)
psi_y &lt;-rnorm(n_y,0,u)
y =  rho*psi_y+ transf(X_y, 1)*(pp1_y*zeta + pp2_y*zeta1)    
</code></pre>

<p>Concatentate the two datasets as above:</p>

<pre><code class="r">D &lt;- rbind(matrix(1,n_y,1),matrix(0,n_p,1)) ## vector of D&#39;s
Y_tilde &lt;- rbind(matrix(y,n_y,1),matrix(psi,n_p,1))## concatenation of y then psi
</code></pre>

<p>Then we concatenate the covariates by rows, those associated with y coming first.</p>

<pre><code class="r">X &lt;- rbind(matrix(X_y,n_y,1),matrix(X_p,n_p,1))
</code></pre>

<p>Then run the test, after modifying the <code>X</code> parameter, the number of core (from 1 to 3), and the number of grid points (from 30 to 5):</p>

<pre><code class="r">tuningParam&lt;- vector(mode=&quot;list&quot;, length=6)
tuningParam[[&quot;p&quot;]] &lt;- 0.05 # the parameter c in  Section 3 in DGM
tuningParam[[&quot;epsilon&quot;]] &lt;- 0.05 # the parameter c in  Section 3 in DGM
tuningParam[[&quot;B&quot;]] &lt;-500 #the number of MC replications
tuningParam[[&quot;y_grid&quot;]] &lt;- quantile(Y_tilde,seq(0,1,length.out=30))
tuningParam[[&quot;c&quot;]] &lt;- 0.3 # the parameter c in  Section 3 in DGM
tuningParam[[&quot;kappa&quot;]] &lt;- 0.001  #the parameter kappa  in  Section 3 in DGM

system.time(res &lt;- test(Y_tilde ,D,X,NULL,NULL,3,tuningParam ))
#&gt; Warning in searchCommandline(parallel, cpus = cpus, type = type,
#&gt; socketHosts = socketHosts, : Unknown option on commandline:
#&gt; tools::buildVignettes(dir
#&gt; snowfall 1.84-6.1 initialized (using snow 0.4-3): parallel execution on 3 CPUs.
#&gt; 
#&gt; Stopping cluster
#&gt; Conditional Moment Inequalities Test   Number of obs :  2400 
#&gt; Test Statistic :  5.472244 
#&gt;  Critical Value (1%)  1.586233 
#&gt; Critical Value (5%)  1.006547 
#&gt; Critical Value (10%)  0.7120133 
#&gt; p-value  :  0
#&gt;    user  system elapsed 
#&gt;    0.97    0.17   74.66

T_n&lt;-  res[[5]] 
p_value &lt;- res[[7]]
</code></pre>

<h3>Estimation of minimal deviations</h3>

<p>The data generating process is the same as for the test without covariates in the previous section:</p>

<pre><code class="r">sig=0.1
u=1
b=0.10
a=2
rho= 0.4

psi &lt;- rnorm(n_p,0,u)
pp_y &lt;- runif(n_y,0,1)
zeta &lt;- rnorm(n_y,a,sig)
zeta1 &lt;- rnorm(n_y,-a,sig)
pp1_y &lt;- 1*(pp_y &lt;b)
pp2_y &lt;- 1*(pp_y &gt;1-b)
pp3_y &lt;- 1*(pp_y &lt;=(1-b) &amp; pp_y &gt;=b)
psi_y &lt;-rnorm(n_p,0,u) 
y =  rho*psi_y+ pp1_y*zeta + pp2_y*zeta1    
</code></pre>

<p>Then we estimate \(g^*\) using the <code>estimDev</code> function, and the two vectors <code>psi</code> and <code>y</code>  with same length</p>

<pre><code class="r">system.time(g_star &lt;- estimDev(psi,y))
#&gt;    user  system elapsed 
#&gt;    6.37    0.02    8.84
</code></pre>

<p>We plot the result on a grid (we refer to  @DGM for a detailled analysis and an enhanced plot):</p>

<pre><code class="r">t&lt;- seq(-2.2,2.2, length.out=300)
plot( t, t- g_star(t),type=&quot;l&quot;,col=1 , lwd=2, xlim=c(-2.2,2.2), ylim=c(min(t- g_star(t))-0.1,max(t- g_star(t))+0.1))
abline(h=0)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-17"/></p>

<h1>References</h1>

</body>

</html>
